package com.bom.tno.smartcore;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.net.*;
import java.nio.charset.*;
import java.security.*;
import java.security.cert.*;
import java.util.Base64;
import java.io.ByteArrayInputStream;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.HostnameVerifier;

import com.amazonaws.services.secretsmanager.AWSSecretsManager;
import com.amazonaws.services.secretsmanager.AWSSecretsManagerClientBuilder;
import com.amazonaws.services.secretsmanager.model.GetSecretValueRequest;
import com.amazonaws.services.secretsmanager.model.GetSecretValueResult;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class ClientCredentialAccessToken implements HostnameVerifier {
	private final String PEM_CERT_START = "-----BEGIN CERTIFICATE-----";
	private final String PEM_CERT_END = "-----END CERTIFICATE-----";
	private final String REDIS_HOST = "-----BEGIN CERTIFICATE-----";
	private final int REDIS_PORT = 0;
	private final String REDIS_CREDENTIAL_SECRET_NAME = "-----BEGIN CERTIFICATE-----";

	private Integer waitInSeconds = Integer.valueOf(60);
	private ClientCredentialsAccessTokenEntity clientCredentialsAccessTokenEntity = null;

	public void setWaitInSeconds(Integer waitInSeconds) {
		this.waitInSeconds = waitInSeconds;
	}

	public static String getSecret(String secretName, String key) throws Exception {
		String localRegion = System.getenv("AWS_REGION");
		if (localRegion == null) {
			localRegion = "us-east-1";
		}
		// Create a Secrets Manager client
		AWSSecretsManager client = AWSSecretsManagerClientBuilder.standard().withRegion(localRegion).build();
		GetSecretValueRequest getSecretValueRequest = new GetSecretValueRequest().withSecretId(secretName);
		GetSecretValueResult getSecretValueResult = null;
		getSecretValueResult = client.getSecretValue(getSecretValueRequest);

		String secret = getSecretValueResult.getSecretString();
		if (secret != null) {
			if (key != null) {
				ObjectMapper objectMapper = new ObjectMapper();
				JsonNode secretsJson = objectMapper.readTree(secret);
				return secretsJson.get(key).textValue();
			} else
				return secret;
		} else
			return new String(Base64.getDecoder().decode(getSecretValueResult.getSecretBinary()).array());
	}

	@SuppressWarnings("unchecked")
	public ClientCredentialsAccessTokenEntity getAccessToken(String username, String password, String tokenEndPoint,
			String proxyHost, int proxyPort, List<String> clientScope, String cert) throws Exception {
		String redisUser = getSecret(REDIS_CREDENTIAL_SECRET_NAME, "user");
		String redisPwd = getSecret(REDIS_CREDENTIAL_SECRET_NAME, "password");
		RedisCacheUtil redis = new RedisCacheUtil(this.REDIS_HOST, this.REDIS_PORT, redisUser, redisPwd);
		String tokenCacheKey = "SCAUTH:${clientId}:${clientScope}:" + tokenEndPoint; // ?
		// Check if token in redis cache. Return if yes 
		String cacheValue = redis.getCacheValue(tokenCacheKey);
		if (cacheValue != null) {
			ObjectMapper mapper = new ObjectMapper();
			this.clientCredentialsAccessTokenEntity = (ClientCredentialsAccessTokenEntity) mapper.readValue(cacheValue,
					ClientCredentialsAccessTokenEntity.class);
			this.clientCredentialsAccessTokenEntity.setStatuscode(200);
			return this.clientCredentialsAccessTokenEntity;
		}

		Map<String, String> formParameters = new HashMap<>();
		formParameters.put("grant_type", "client_credentials");
		if (clientScope != null && clientScope.size() > 0)
			formParameters.put("scope", String.join(" ", (Iterable) clientScope));
		byte[] postFormData = getDataString(formParameters).getBytes(StandardCharsets.UTF_8);
		int postFormDataLen = postFormData.length;
		URL url = new URL(tokenEndPoint);
		URLConnection con = null;
		if ((((proxyHost != null) ? 1 : 0) & ((proxyHost.length() > 3) ? 1 : 0)) != 0) {
			InetSocketAddress proxyLocation = new InetSocketAddress(proxyHost, proxyPort);
			Proxy proxy = new Proxy(Proxy.Type.HTTP, proxyLocation);
			con = url.openConnection(proxy);
		} else {
			con = url.openConnection();
		}
		if (con instanceof HttpsURLConnection && cert != null && cert.length() > 0)
			setTrustStore(cert, (HttpsURLConnection) con);

		HttpURLConnection https = (HttpURLConnection) con;
		https.setConnectTimeout(this.waitInSeconds.intValue() * 1000);
		https.setRequestMethod("POST");
		https.setRequestProperty("Authorization", basicAuth(username, password));
		https.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
		https.setRequestProperty("Content-Length", Integer.toString(postFormDataLen));
		https.setRequestProperty("charset", "utf-8");
		https.setDoOutput(true);
		OutputStream outputStr = https.getOutputStream();
		DataOutputStream dataOutputStreamRequest = new DataOutputStream(outputStr);
		dataOutputStreamRequest.write(postFormData);
		dataOutputStreamRequest.flush();
		dataOutputStreamRequest.close();
		this.clientCredentialsAccessTokenEntity.setStatuscode(Integer.valueOf(https.getResponseCode()));
		BufferedReader responseStreamReader = null;
		InputStream responseStream = null;
		if (https.getResponseCode() == 200) {
			responseStream = new BufferedInputStream(https.getInputStream());
		} else {
			responseStream = new BufferedInputStream(https.getErrorStream());
		}
		responseStreamReader = new BufferedReader(new InputStreamReader(responseStream));
		String line = "";
		StringBuilder stringBuilder = new StringBuilder();
		while ((line = responseStreamReader.readLine()) != null)
			stringBuilder.append(line).append("\n");
		responseStreamReader.close();
		String response = stringBuilder.toString();
		ObjectMapper mapper = new ObjectMapper();
		this.clientCredentialsAccessTokenEntity = (ClientCredentialsAccessTokenEntity) mapper.readValue(response,
				ClientCredentialsAccessTokenEntity.class);
		this.clientCredentialsAccessTokenEntity.setStatuscode(Integer.valueOf(https.getResponseCode()));
		// save token to redis cache
		redis.upsertCacheEntry(tokenCacheKey, cacheValue, false);
		return this.clientCredentialsAccessTokenEntity;
	}

	private String basicAuth(String username, String password) {
		String basicAuth = "Basic " + Base64.getEncoder().encodeToString((username + ":" + password).getBytes());
		return basicAuth;
	}

	private String getDataString(Map<String, String> params) throws UnsupportedEncodingException {
		StringBuilder result = new StringBuilder();
		boolean first = true;
		for (Map.Entry<String, String> entry : params.entrySet()) {
			if (first) {
				first = false;
			} else {
				result.append("&");
			}
			result.append(URLEncoder.encode(entry.getKey(), "UTF-8"));
			result.append("=");
			result.append(URLEncoder.encode(entry.getValue(), "UTF-8"));
		}
		return result.toString();
	}

	private void setTrustStore(String ServerCert, HttpsURLConnection con) throws Exception {
		KeyStore truststore = KeyStore.getInstance("JKS");
		CertificateFactory factory = CertificateFactory.getInstance("X.509");
		String[] certs = ServerCert.split(PEM_CERT_END);
		List<X509Certificate> certList = new ArrayList<>();
		for (int i = 0; i < certs.length; i++) {
			String[] split2 = certs[i].split(PEM_CERT_START);
			if (split2.length > 1) {
				String certBody = split2[1].replaceAll("\\s", "");
				byte[] certBytes = Base64.getDecoder().decode(certBody);
				certList.add((X509Certificate) factory.generateCertificate(new ByteArrayInputStream(certBytes)));
			}
		}

		X509Certificate[] smallChain = new X509Certificate[1];
		X509Certificate[] certChain = certList.<X509Certificate>toArray(smallChain);
		TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
		tmf.init((KeyStore) null);
		TrustManager[] tm = tmf.getTrustManagers();
		SSLContext sc = SSLContext.getInstance("TLSv1.2");
		sc.init(null, tm, new SecureRandom());
		HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
		// Object object = new Object (this);
		Object object = this;
		HttpsURLConnection.setDefaultHostnameVerifier((HostnameVerifier) object);
	}

	@Override
	public boolean verify(String hostname, SSLSession session) {
		return true;
	}

}
